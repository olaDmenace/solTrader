#!/usr/bin/env python3
"""
Test script for live trading integration components
This script tests the new live trading functionality without executing real trades
"""
import asyncio
import os
import sys
import logging
from unittest.mock import Mock, AsyncMock, patch
from datetime import datetime

# Add src to path
sys.path.append(os.path.join(os.path.dirname(__file__), 'src'))

from src.phantom_wallet import PhantomWallet
from src.api.jupiter import JupiterClient
from src.api.alchemy import AlchemyClient
from src.trading.transaction_manager import TransactionManager, TransactionStatus
from src.trading.emergency_controls import EmergencyControls, CircuitBreakerConfig
from src.security.wallet_security import WalletSecurity, RateLimiter, InputValidator
from src.config.settings import Settings

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)


class LiveTradingIntegrationTester:
    """Test suite for live trading integration"""
    
    def __init__(self):
        self.test_results = []
        
    async def run_all_tests(self) -> None:
        """Run all integration tests"""
        logger.info("Starting live trading integration tests...")
        
        tests = [
            self.test_wallet_security(),
            self.test_phantom_wallet_integration(),
            self.test_jupiter_client_enhancements(),
            self.test_transaction_manager(),
            self.test_emergency_controls(),
            self.test_rate_limiting(),
            self.test_input_validation(),
            self.test_environment_configuration(),
        ]
        
        for test in tests:
            try:
                await test
                logger.info(f"✅ {test.__name__} passed")
                self.test_results.append((test.__name__, True, None))
            except Exception as e:
                logger.error(f"❌ {test.__name__} failed: {str(e)}")
                self.test_results.append((test.__name__, False, str(e)))\n        
        self.print_test_summary()\n    \n    async def test_wallet_security(self) -> None:\n        \"\"\"Test wallet security functions\"\"\"\n        logger.info(\"Testing wallet security...\")\n        \n        # Test private key validation\n        valid_key = \"5KQwrPbwdL6PhXujxW37FSSQZ1JiwsST4cqQzDeyXtP79zkvFD3\"  # Example key\n        assert WalletSecurity.validate_private_key(valid_key) == False  # Should be False for this example\n        \n        # Test weak key detection\n        weak_key = \"1111111111111111111111111111111111111111111111\"\n        assert WalletSecurity.validate_private_key(weak_key) == False\n        \n        # Test wallet address validation\n        valid_address = \"JxKzzx2Hif9fnpg9J6jY8XfwYnSLHF6CQZK7zT9ScNb\"\n        assert WalletSecurity.validate_wallet_address(valid_address) == True\n        \n        # Test log data sanitization\n        sensitive_data = {\n            \"private_key\": \"secret123\",\n            \"amount\": 100,\n            \"signature\": \"very_long_signature_string_here\"\n        }\n        sanitized = WalletSecurity.sanitize_log_data(sensitive_data)\n        assert sanitized[\"private_key\"] == \"[REDACTED]\"\n        assert sanitized[\"amount\"] == 100\n        \n        logger.info(\"Wallet security tests completed\")\n    \n    async def test_phantom_wallet_integration(self) -> None:\n        \"\"\"Test PhantomWallet live trading integration\"\"\"\n        logger.info(\"Testing PhantomWallet integration...\")\n        \n        # Mock Alchemy client\n        mock_alchemy = Mock(spec=AlchemyClient)\n        mock_alchemy.get_balance = AsyncMock(return_value=10.0)\n        mock_alchemy.get_token_accounts = AsyncMock(return_value={'result': {'value': []}})\n        \n        wallet = PhantomWallet(mock_alchemy)\n        \n        # Test wallet properties\n        assert wallet.live_mode == False\n        assert wallet.keypair is None\n        assert wallet.rpc_client is None\n        \n        # Test address validation\n        assert wallet._validate_address(\"JxKzzx2Hif9fnpg9J6jY8XfwYnSLHF6CQZK7zT9ScNb\") == True\n        assert wallet._validate_address(\"invalid\") == False\n        \n        # Test connection\n        connected = await wallet.connect(\"JxKzzx2Hif9fnpg9J6jY8XfwYnSLHF6CQZK7zT9ScNb\")\n        assert connected == True\n        assert wallet.connected == True\n        \n        await wallet.disconnect()\n        assert wallet.connected == False\n        \n        logger.info(\"PhantomWallet integration tests completed\")\n    \n    async def test_jupiter_client_enhancements(self) -> None:\n        \"\"\"Test Jupiter client enhancements\"\"\"\n        logger.info(\"Testing Jupiter client enhancements...\")\n        \n        client = JupiterClient()\n        \n        # Test with mock response\n        mock_quote = {\n            \"inputMint\": \"So11111111111111111111111111111111111111112\",\n            \"outputMint\": \"EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v\",\n            \"inAmount\": \"1000000000\",\n            \"outAmount\": \"100000000\",\n            \"priceImpactPct\": \"0.1\"\n        }\n        \n        with patch.object(client, 'get_quote', return_value=mock_quote):\n            quote = await client.get_quote(\n                input_mint=\"So11111111111111111111111111111111111111112\",\n                output_mint=\"EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v\",\n                amount=\"1000000000\",\n                slippageBps=50\n            )\n            assert quote == mock_quote\n        \n        # Test execute_swap method (without actual execution)\n        with patch.object(client, 'get_quote', return_value=mock_quote):\n            result = await client.execute_swap(\n                input_token=\"So11111111111111111111111111111111111111112\",\n                output_token=\"EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v\",\n                amount=1.0,\n                slippage=0.01\n            )\n            assert result == True  # Should return True for successful quote\n        \n        await client.close()\n        logger.info(\"Jupiter client enhancement tests completed\")\n    \n    async def test_transaction_manager(self) -> None:\n        \"\"\"Test transaction manager functionality\"\"\"\n        logger.info(\"Testing transaction manager...\")\n        \n        # Mock RPC client\n        mock_rpc = Mock()\n        mock_rpc.send_transaction = AsyncMock(return_value=Mock(value=\"test_signature\"))\n        mock_rpc.get_signature_status = AsyncMock(return_value=Mock(\n            value=[Mock(err=None, confirmation_status=Mock(value=\"confirmed\"))]\n        ))\n        \n        tx_manager = TransactionManager(mock_rpc)\n        \n        # Test transaction submission\n        mock_tx = Mock()\n        signature = await tx_manager.submit_transaction(mock_tx)\n        assert signature == \"test_signature\"\n        \n        # Test status checking\n        status = await tx_manager.get_transaction_status(\"test_signature\")\n        assert status == TransactionStatus.CONFIRMED\n        \n        # Test monitoring start/stop\n        await tx_manager.start_monitoring()\n        assert tx_manager._monitoring == True\n        \n        await tx_manager.stop_monitoring()\n        assert tx_manager._monitoring == False\n        \n        logger.info(\"Transaction manager tests completed\")\n    \n    async def test_emergency_controls(self) -> None:\n        \"\"\"Test emergency control system\"\"\"\n        logger.info(\"Testing emergency controls...\")\n        \n        config = CircuitBreakerConfig(\n            max_daily_loss=50.0,\n            max_position_size=100.0,\n            position_limit=3\n        )\n        \n        emergency = EmergencyControls(config)\n        \n        # Test circuit breaker checks\n        result = await emergency.check_circuit_breakers(\n            current_balance=10.0,\n            current_positions={\"token1\": {}, \"token2\": {}},\n            daily_pnl=-20.0,  # Within limits\n            error_count=2,\n            trade_count=5\n        )\n        assert result == True  # Should pass\n        \n        # Test with breached limits\n        result = await emergency.check_circuit_breakers(\n            current_balance=10.0,\n            current_positions={\"token1\": {}, \"token2\": {}, \"token3\": {}, \"token4\": {}},  # Over limit\n            daily_pnl=-60.0,  # Over daily loss limit\n            error_count=2,\n            trade_count=5\n        )\n        assert result == False  # Should fail\n        \n        # Test emergency stop\n        await emergency.emergency_stop(\"Test emergency\")\n        assert emergency.emergency_stop_active == True\n        \n        # Test pause operation\n        await emergency.pause_operation(\"trading\", 1)  # 1 second pause\n        assert emergency.is_operation_paused(\"trading\") == True\n        \n        await asyncio.sleep(1.1)  # Wait for pause to expire\n        assert emergency.is_operation_paused(\"trading\") == True  # Still true due to emergency stop\n        \n        emergency.clear_emergency_stop()\n        assert emergency.emergency_stop_active == False\n        \n        logger.info(\"Emergency controls tests completed\")\n    \n    async def test_rate_limiting(self) -> None:\n        \"\"\"Test rate limiting functionality\"\"\"\n        logger.info(\"Testing rate limiting...\")\n        \n        rate_limiter = RateLimiter()\n        rate_limiter.limits['test'] = {'count': 3, 'window': 60}\n        \n        # Test within limits\n        assert rate_limiter.is_allowed('test') == True\n        assert rate_limiter.is_allowed('test') == True\n        assert rate_limiter.is_allowed('test') == True\n        \n        # Test over limits\n        assert rate_limiter.is_allowed('test') == False\n        \n        # Test status\n        status = rate_limiter.get_status()\n        assert 'test' in status\n        assert status['test']['current_count'] == 3\n        assert status['test']['remaining'] == 0\n        \n        # Test reset\n        rate_limiter.reset_limits()\n        assert rate_limiter.is_allowed('test') == True\n        \n        logger.info(\"Rate limiting tests completed\")\n    \n    async def test_input_validation(self) -> None:\n        \"\"\"Test input validation utilities\"\"\"\n        logger.info(\"Testing input validation...\")\n        \n        # Test amount validation\n        assert InputValidator.validate_amount(100.0) == True\n        assert InputValidator.validate_amount(-1.0) == False\n        assert InputValidator.validate_amount(\"invalid\") == False\n        \n        # Test slippage validation\n        assert InputValidator.validate_slippage(0.01) == True  # 1%\n        assert InputValidator.validate_slippage(0.6) == False  # 60% - too high\n        assert InputValidator.validate_slippage(-0.01) == False  # Negative\n        \n        # Test priority fee validation\n        assert InputValidator.validate_priority_fee(5000) == True\n        assert InputValidator.validate_priority_fee(None) == True  # Optional\n        assert InputValidator.validate_priority_fee(-1) == False\n        assert InputValidator.validate_priority_fee(2000000) == False  # Too high\n        \n        # Test string sanitization\n        dirty_string = \"Hello <script>alert('xss')</script> World!\"\n        clean_string = InputValidator.sanitize_string(dirty_string)\n        assert \"<script>\" not in clean_string\n        assert \"Hello\" in clean_string\n        \n        logger.info(\"Input validation tests completed\")\n    \n    async def test_environment_configuration(self) -> None:\n        \"\"\"Test environment configuration loading\"\"\"\n        logger.info(\"Testing environment configuration...\")\n        \n        # Test that critical environment variables are defined\n        required_vars = [\n            'LIVE_TRADING_ENABLED',\n            'SOLANA_NETWORK',\n            'MAX_DAILY_LOSS',\n            'TRANSACTION_TIMEOUT'\n        ]\n        \n        # Set test values temporarily\n        original_values = {}\n        for var in required_vars:\n            original_values[var] = os.getenv(var)\n            \n        try:\n            # Set test values\n            os.environ['LIVE_TRADING_ENABLED'] = 'false'\n            os.environ['SOLANA_NETWORK'] = 'devnet'\n            os.environ['MAX_DAILY_LOSS'] = '100.0'\n            os.environ['TRANSACTION_TIMEOUT'] = '60'\n            \n            # Test that values can be read\n            assert os.getenv('LIVE_TRADING_ENABLED') == 'false'\n            assert os.getenv('SOLANA_NETWORK') == 'devnet'\n            assert float(os.getenv('MAX_DAILY_LOSS')) == 100.0\n            assert int(os.getenv('TRANSACTION_TIMEOUT')) == 60\n            \n        finally:\n            # Restore original values\n            for var, value in original_values.items():\n                if value is not None:\n                    os.environ[var] = value\n                elif var in os.environ:\n                    del os.environ[var]\n        \n        logger.info(\"Environment configuration tests completed\")\n    \n    def print_test_summary(self) -> None:\n        \"\"\"Print test results summary\"\"\"\n        print(\"\\n\" + \"=\"*60)\n        print(\"LIVE TRADING INTEGRATION TEST SUMMARY\")\n        print(\"=\"*60)\n        \n        passed = 0\n        failed = 0\n        \n        for test_name, success, error in self.test_results:\n            status = \"✅ PASSED\" if success else \"❌ FAILED\"\n            print(f\"{test_name:<40} {status}\")\n            if not success and error:\n                print(f\"  Error: {error}\")\n            \n            if success:\n                passed += 1\n            else:\n                failed += 1\n        \n        print(\"\\n\" + \"-\"*60)\n        print(f\"Total: {len(self.test_results)} | Passed: {passed} | Failed: {failed}\")\n        \n        if failed == 0:\n            print(\"\\n🎉 All tests passed! Live trading integration is ready.\")\n        else:\n            print(f\"\\n⚠️  {failed} test(s) failed. Please review and fix issues before using live trading.\")\n        \n        print(\"\\n📋 NEXT STEPS:\")\n        print(\"1. Set PRIVATE_KEY in .env for live trading\")\n        print(\"2. Set LIVE_TRADING_ENABLED=true when ready\")\n        print(\"3. Start with small amounts on devnet\")\n        print(\"4. Monitor logs and emergency controls\")\n        print(\"5. Test thoroughly before mainnet use\")\n        print(\"\\n⚠️  WARNING: Live trading involves real money. Test carefully!\")\n\n\nasync def main():\n    \"\"\"Run the integration tests\"\"\"\n    tester = LiveTradingIntegrationTester()\n    await tester.run_all_tests()\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())