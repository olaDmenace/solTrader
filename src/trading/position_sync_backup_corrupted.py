"""
position_sync.py - Position synchronization with blockchain state
"""
import logging
import asyncio
from typing import Dict, Optional, List, Any, Tuple
from datetime import datetime, timedelta
from dataclasses import dataclass, field
from decimal import Decimal

logger = logging.getLogger(__name__)


@dataclass
class SyncResult:
    """Result of position synchronization"""
    success: bool
    updated_positions: List[str] = field(default_factory=list)
    removed_positions: List[str] = field(default_factory=list)
    errors: List[str] = field(default_factory=list)
    sync_time: datetime = field(default_factory=datetime.now)


class PositionSynchronizer:
    """Synchronize trading positions with blockchain state"""
    
    def __init__(self, wallet, jupiter_client, position_manager):
        """
        Initialize position synchronizer
        
        Args:
            wallet: PhantomWallet instance
            jupiter_client: JupiterClient instance  
            position_manager: PositionManager instance
        """
        self.wallet = wallet
        self.jupiter = jupiter_client
        self.position_manager = position_manager
        
        self.last_sync: Optional[datetime] = None
        self.sync_interval = 300  # 5 minutes default
        self.tolerance = 0.001  # 0.1% tolerance for balance differences
        
        # Monitoring
        self._sync_task: Optional[asyncio.Task] = None
        self._monitoring = False\n    \n    async def start_monitoring(self, interval: int = 300) -> None:\n        \"\"\"Start automatic position synchronization\"\"\"\n        if self._monitoring:\n            return\n            \n        self.sync_interval = interval\n        self._monitoring = True\n        self._sync_task = asyncio.create_task(self._sync_loop())\n        \n        logger.info(f\"Position synchronization monitoring started (interval: {interval}s)\")\n    \n    async def stop_monitoring(self) -> None:\n        \"\"\"Stop automatic synchronization\"\"\"\n        self._monitoring = False\n        \n        if self._sync_task and not self._sync_task.done():\n            self._sync_task.cancel()\n            try:\n                await self._sync_task\n            except asyncio.CancelledError:\n                pass\n                \n        logger.info(\"Position synchronization monitoring stopped\")\n    \n    async def sync_positions(self, force: bool = False) -> SyncResult:\n        \"\"\"\n        Synchronize positions with blockchain state\n        \n        Args:\n            force: Force sync even if recently synced\n            \n        Returns:\n            SyncResult with sync details\n        \"\"\"\n        try:\n            # Check if sync needed\n            if not force and self._is_recently_synced():\n                logger.debug(\"Skipping sync - recently synchronized\")\n                return SyncResult(success=True)\n                \n            if not self.wallet.live_mode:\n                logger.warning(\"Cannot sync positions - wallet not in live mode\")\n                return SyncResult(success=False, errors=[\"Wallet not in live mode\"])\n                \n            logger.info(\"Starting position synchronization...\")\n            \n            # Get blockchain token balances\n            blockchain_balances = await self._get_blockchain_balances()\n            if not blockchain_balances:\n                return SyncResult(success=False, errors=[\"Failed to get blockchain balances\"])\n                \n            # Get managed positions\n            managed_positions = self.position_manager.positions.copy()\n            \n            # Sync positions\n            result = await self._reconcile_positions(blockchain_balances, managed_positions)\n            \n            # Update last sync time\n            self.last_sync = datetime.now()\n            \n            logger.info(\n                f\"Position sync completed: {len(result.updated_positions)} updated, \"\n                f\"{len(result.removed_positions)} removed\"\n            )\n            \n            return result\n            \n        except Exception as e:\n            logger.error(f\"Error during position synchronization: {str(e)}\")\n            return SyncResult(success=False, errors=[str(e)])\n    \n    async def _sync_loop(self) -> None:\n        \"\"\"Automatic synchronization loop\"\"\"\n        while self._monitoring:\n            try:\n                await self.sync_positions()\n                await asyncio.sleep(self.sync_interval)\n                \n            except asyncio.CancelledError:\n                break\n            except Exception as e:\n                logger.error(f\"Error in sync loop: {str(e)}\")\n                await asyncio.sleep(60)  # Wait before retrying\n    \n    async def _get_blockchain_balances(self) -> Optional[Dict[str, float]]:\n        \"\"\"Get actual token balances from blockchain\"\"\"\n        try:\n            token_accounts = await self.wallet.get_token_accounts()\n            balances = {}\n            \n            for account in token_accounts:\n                mint = account.get('mint')\n                balance = account.get('balance', 0.0)\n                \n                if mint and balance > 0:\n                    balances[mint] = float(balance)\n                    \n            logger.debug(f\"Retrieved {len(balances)} token balances from blockchain\")\n            return balances\n            \n        except Exception as e:\n            logger.error(f\"Error getting blockchain balances: {str(e)}\")\n            return None\n    \n    async def _reconcile_positions(\n        self, \n        blockchain_balances: Dict[str, float],\n        managed_positions: Dict[str, Any]\n    ) -> SyncResult:\n        \"\"\"Reconcile managed positions with blockchain reality\"\"\"\n        result = SyncResult(success=True)\n        \n        try:\n            # Check existing positions\n            for token_address, position in managed_positions.items():\n                blockchain_balance = blockchain_balances.get(token_address, 0.0)\n                managed_balance = position.size\n                \n                # Calculate difference\n                diff = abs(blockchain_balance - managed_balance)\n                relative_diff = diff / max(managed_balance, 0.001)  # Avoid division by zero\n                \n                if relative_diff > self.tolerance:\n                    if blockchain_balance == 0.0:\n                        # Position closed on blockchain but still managed\n                        logger.warning(\n                            f\"Position {token_address} closed on blockchain, removing from management\"\n                        )\n                        await self._remove_managed_position(token_address)\n                        result.removed_positions.append(token_address)\n                        \n                    else:\n                        # Balance mismatch - update managed position\n                        logger.info(\n                            f\"Updating position {token_address}: {managed_balance} -> {blockchain_balance}\"\n                        )\n                        await self._update_position_size(token_address, blockchain_balance)\n                        result.updated_positions.append(token_address)\n            \n            # Check for new positions on blockchain not in management\n            for token_address, balance in blockchain_balances.items():\n                if token_address not in managed_positions and balance > self.tolerance:\n                    # Found unmanaged position on blockchain\n                    logger.info(f\"Found unmanaged position {token_address}: {balance}\")\n                    \n                    # Get current price and create position\n                    current_price = await self._get_current_price(token_address)\n                    if current_price:\n                        await self._create_managed_position(\n                            token_address, balance, current_price\n                        )\n                        result.updated_positions.append(token_address)\n                    else:\n                        result.errors.append(f\"Failed to get price for {token_address}\")\n            \n            return result\n            \n        except Exception as e:\n            logger.error(f\"Error reconciling positions: {str(e)}\")\n            result.success = False\n            result.errors.append(str(e))\n            return result\n    \n    async def _remove_managed_position(self, token_address: str) -> None:\n        \"\"\"Remove position from management\"\"\"\n        try:\n            if token_address in self.position_manager.positions:\n                position = self.position_manager.positions[token_address]\n                \n                # Close position with sync reason\n                await self.position_manager.close_position(\n                    token_address, \n                    reason=\"position_sync_closed\"\n                )\n                \n                logger.info(f\"Removed managed position: {token_address}\")\n                \n        except Exception as e:\n            logger.error(f\"Error removing managed position {token_address}: {str(e)}\")\n    \n    async def _update_position_size(self, token_address: str, new_size: float) -> None:\n        \"\"\"Update position size in management\"\"\"\n        try:\n            if token_address in self.position_manager.positions:\n                position = self.position_manager.positions[token_address]\n                old_size = position.size\n                \n                # Update position size\n                position.size = new_size\n                \n                # Update position value and PnL\n                current_price = await self._get_current_price(token_address)\n                if current_price:\n                    position.update_price(current_price, 0)  # Volume not critical for sync\n                    \n                logger.info(\n                    f\"Updated position size {token_address}: {old_size} -> {new_size}\"\n                )\n                \n        except Exception as e:\n            logger.error(f\"Error updating position size {token_address}: {str(e)}\")\n    \n    async def _create_managed_position(\n        self, \n        token_address: str, \n        size: float, \n        current_price: float\n    ) -> None:\n        \"\"\"Create managed position for untracked blockchain position\"\"\"\n        try:\n            # Create position with current price as entry (best estimate)\n            await self.position_manager.open_position(\n                token_address=token_address,\n                size=size,\n                entry_price=current_price,  # Use current price as entry estimate\n                stop_loss=current_price * 0.9,  # 10% stop loss\n                take_profit=current_price * 1.2,  # 20% take profit\n                source=\"position_sync\"\n            )\n            \n            logger.info(\n                f\"Created managed position for {token_address}: \"\n                f\"size={size}, price={current_price}\"\n            )\n            \n        except Exception as e:\n            logger.error(f\"Error creating managed position {token_address}: {str(e)}\")\n    \n    async def _get_current_price(self, token_address: str) -> Optional[float]:\n        \"\"\"Get current price for token\"\"\"\n        try:\n            price_data = await self.jupiter.get_price(\n                input_mint=token_address,\n                output_mint=\"EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v\",  # USDC\n                amount=1000000  # 1 USDC worth\n            )\n            \n            if price_data and 'outAmount' in price_data:\n                out_amount = float(price_data['outAmount'])\n                return out_amount / 1e9 if out_amount > 0 else None\n                \n            return None\n            \n        except Exception as e:\n            logger.error(f\"Error getting current price for {token_address}: {str(e)}\")\n            return None\n    \n    def _is_recently_synced(self, max_age_minutes: int = 5) -> bool:\n        \"\"\"Check if positions were recently synchronized\"\"\"\n        if not self.last_sync:\n            return False\n            \n        age = datetime.now() - self.last_sync\n        return age < timedelta(minutes=max_age_minutes)\n    \n    async def force_sync_position(self, token_address: str) -> bool:\n        \"\"\"Force synchronization of specific position\"\"\"\n        try:\n            if not self.wallet.live_mode:\n                logger.error(\"Cannot sync position - wallet not in live mode\")\n                return False\n                \n            # Get blockchain balance for this token\n            token_accounts = await self.wallet.get_token_accounts()\n            blockchain_balance = 0.0\n            \n            for account in token_accounts:\n                if account.get('mint') == token_address:\n                    blockchain_balance = float(account.get('balance', 0.0))\n                    break\n            \n            # Get managed position\n            managed_position = self.position_manager.positions.get(token_address)\n            \n            if not managed_position and blockchain_balance > self.tolerance:\n                # Create missing managed position\n                current_price = await self._get_current_price(token_address)\n                if current_price:\n                    await self._create_managed_position(\n                        token_address, blockchain_balance, current_price\n                    )\n                    return True\n                    \n            elif managed_position:\n                if blockchain_balance == 0.0:\n                    # Remove managed position\n                    await self._remove_managed_position(token_address)\n                    return True\n                else:\n                    # Update position size\n                    await self._update_position_size(token_address, blockchain_balance)\n                    return True\n                    \n            return False\n            \n        except Exception as e:\n            logger.error(f\"Error force syncing position {token_address}: {str(e)}\")\n            return False\n    \n    def get_sync_status(self) -> Dict[str, Any]:\n        \"\"\"Get synchronization status information\"\"\"\n        return {\n            'monitoring': self._monitoring,\n            'last_sync': self.last_sync.isoformat() if self.last_sync else None,\n            'sync_interval': self.sync_interval,\n            'tolerance': self.tolerance,\n            'wallet_live_mode': self.wallet.live_mode,\n            'managed_positions': len(self.position_manager.positions)\n        }\n    \n    async def validate_all_positions(self) -> Dict[str, Any]:\n        \"\"\"Validate all positions against blockchain state\"\"\"\n        try:\n            if not self.wallet.live_mode:\n                return {'error': 'Wallet not in live mode'}\n                \n            blockchain_balances = await self._get_blockchain_balances()\n            if not blockchain_balances:\n                return {'error': 'Failed to get blockchain balances'}\n                \n            managed_positions = self.position_manager.positions\n            validation_results = {\n                'total_managed': len(managed_positions),\n                'total_blockchain': len(blockchain_balances),\n                'matches': 0,\n                'discrepancies': [],\n                'unmanaged_tokens': [],\n                'orphaned_positions': []\n            }\n            \n            # Check managed positions\n            for token_address, position in managed_positions.items():\n                blockchain_balance = blockchain_balances.get(token_address, 0.0)\n                managed_balance = position.size\n                \n                diff = abs(blockchain_balance - managed_balance)\n                relative_diff = diff / max(managed_balance, 0.001)\n                \n                if relative_diff <= self.tolerance:\n                    validation_results['matches'] += 1\n                else:\n                    validation_results['discrepancies'].append({\n                        'token': token_address,\n                        'managed': managed_balance,\n                        'blockchain': blockchain_balance,\n                        'difference': diff,\n                        'relative_diff': relative_diff\n                    })\n            \n            # Check for unmanaged positions\n            for token_address, balance in blockchain_balances.items():\n                if token_address not in managed_positions and balance > self.tolerance:\n                    validation_results['unmanaged_tokens'].append({\n                        'token': token_address,\n                        'balance': balance\n                    })\n            \n            # Check for orphaned positions\n            for token_address in managed_positions:\n                if token_address not in blockchain_balances:\n                    validation_results['orphaned_positions'].append(token_address)\n                    \n            return validation_results\n            \n        except Exception as e:\n            logger.error(f\"Error validating positions: {str(e)}\")\n            return {'error': str(e)}